// *****************************************************************************************************************************************
// Este app irá traduzir ou preparar uma tradução para qualquer língua
// Sintaxe:
// jsontrans translate /file.json pt en                 --> Traduz o arquivo file.json em português para o inglês
// jsontrans prepare /file.json pt en                   --> Prepara um arquivo tsv para ser traduzido para o inglês a partir de file.json
// jsontrans transform /file.tsv /file.json newfilename --> Aplica os textos de file.tsv em file.json (que foi usado para cria-lo)e o salva
//                                                          com o nome newfilename.json onde file.tsv é um arquivo traduzido gerado com o 
//                                                          comando prepare
// *****************************************************************************************************************************************

(async function() {

    var googleTrans = require('@vitalets/google-translate-api');
    var fs = require('fs');
    var args = process.argv.slice(2);
    var path = require('path');
    var version = require('./package.json').version || '';
    var cp = require('chroma-palette');
    var log = console.log;
    var os = require('os');

/*     let rrr = await translateGoogle('Entenda por que o preço dos alimentos ainda pesa tanto no bolso apesar da deflação', 'en', 'pt')
    log('---> ' + rrr)
    process.exit(0); */

    if (!args.length || args[0].toLowerCase() == '--help' || args[0].toLowerCase() == '-h') { console.log(path.normalize('/testing/pt.json'))
        console.info(`

${cp.red.paint(' _   _   _         ___ __   _        _       _  ___  _  __ ')}
${cp.red.paint('  | (_  / \\ |\\ |    |  |_) /_\\ |\\ | (_  |   /_\\  |  / \\ |_)')}
${cp.red.paint('(_|  _) \\_/ | \\|    |  | \\ | | | \\|  _) |_  | |  |  \\ / | \\')}
===========================================================
${cp.yellow.paint('by Walter Staeblein  v. ' + version)}
===========================================================

This app can translate almost any JSON file or prepare a JSON file for translation as a TSV file.
You can use the following commands:

${cp.red.paint('1- Automatic Translation')}
------------------------
${cp.yellow.paint('jsontrans translate /myfile.json pt en')}

Translate myfile.json from portuguese (pt) to english (en) using Google Translator. 
If the  file name is equal  to the language  ISO code then the resulting  file will 
follow suit. Otherwise the language code will be appended to the name. In this case 
the file myfile-en.json will be created.


${cp.red.paint('2- Prepare File For Manual Translation')}
--------------------------------------
${cp.yellow.paint('jsontrans prepare /myfile.json pt en')}

Will create myfile.tsv from myfile.json. The first language code is the one the JSON
file is in and the second is the target language of the translation.  This file will 
have 3 columns. The first is a dot notation to the respective field in the JSON, the 
second  is the value of the field and the  third is empty so that the translator can 
fill it in and give back to be transformed.


 ${cp.red.paint('3- Transforms a Translated File')}
-------------------------------
${cp.yellow.paint('jsontrans transform /myfile.tsv /myfile.json newfilename')}

Turns the original JSON file  (used to generate the TSV with command 2 and passed as
myfile.json)  into a new JSON file with the translation in place.  The name for this 
new file is passed in newfilename and it's structure will be the same as myfile.json
but the values will be replaced with the ones from myfile.tsv.

 ------------------------------------------------------------------------------------

${cp.green.paint('Observations:')}
=============

- The TSV extension indicates tab separated files, much like CSVs but instead of
  commas or semicolons TABs are used to separate cells.

- Existing files will be overwritten without warning.

- The tsv files generated by this app must not be changed. The translator should
  only fill the third column with the appropriate translations and nothing else.

- Transform command supposes TSV file's first line is a header and will be ignored.

        `)
        process.exit(0);

    } else {
        let op = args[0].toLowerCase();
        let tsvfile = '';
        let jsonfile = '';
        let currlang = '', outlang = '';
        let startTime = new Date().getTime();

        // node . translate ./testing/pt.json pt it 
        switch (op) {
            case 'translate':
                if (args.length != 4) { 
                    endThis(`${cp.red.paint('ERROR: ')}Arguments are wrong or in insuficient number`); 
                }
                currlang = args[2].toLowerCase();
                outlang = args[3].toLowerCase();
                
                try {
                    let fn = args[1];
                    let pth = makePath(fn);
                    jsonfile = JSON.parse(fs.readFileSync(pth, { encoding:'utf8' })); 
                    let newJSON = await translate(jsonfile, currlang, outlang);

                    let parsePth = path.parse(pth);
                    let newpath = path.join(parsePth.dir, (parsePth.name.toLowerCase() == currlang ? outlang : parsePth.name + '-' + outlang) + '.json');

                    fs.writeFileSync(newpath, JSON.stringify(newJSON, null, 4), { encoding:'utf8' });

                } catch (error) {
                    log(error);
                    endThis(`${cp.red.paint('ERROR: ')}An unexpected error has occurred!!`, 1);
                }
                break;

            case 'prepare':
                if (args.length != 4) { endThis(`${cp.red.paint('ERROR: ')}Arguments are wrong or in insuficient number`); }
                jsonfile = path.resolve(args[1]);
                currlang = args[2];
                outlang = args[3];

                try {
                    let fn = args[1];
                    let pth = makePath(fn, '');
                    let jsonObj = JSON.parse(fs.readFileSync(pth, {encoding:'utf8'}));
                    let newTSV = prepare(jsonObj, currlang, outlang);

                    let parsePth = path.parse(pth);
                    let newpath = path.join(parsePth.dir, parsePth.name + '-' + outlang + '.tsv');

                    log(newTSV)
                    fs.writeFileSync(newpath, newTSV, { encoding:'utf8' });

                } catch (error) {
                    log(error.message);
                    endThis(`${cp.red.paint('ERROR: ')}[${error.message.replace(':', ']')}`, 1);
                }

                break;

            case 'transform':
                if (args.length != 4) { endThis(`${cp.red.paint('ERROR: ')}Argumentos insuficientes`); }
                tsvpath = path.resolve(args[1]);
                jsonpath = path.resolve(args[2]);
                let newfn = args[3];
                let jsonObj, tsvObj;

                // Lê JSON
                try {
                    jsonObj = JSON.parse(fs.readFileSync(jsonpath, {encoding:'utf8'}));

                } catch (error) {
                    endThis(`${cp.red.paint('ERROR: ')}File ${jsonpath} not found or could not be opened`, 1);
                }

                // Lê TSV
                try {
                    tsvObj = fs.readFileSync(tsvpath, {encoding:'utf8'}).split(os.EOL);

                } catch (error) {
                    endThis(`${cp.red.paint('ERROR: ')}File ${tsvpath} not found or could not be opened`, 1);
                }

                let parsePth = path.parse(makePath(jsonpath));
                let outpath = path.join(parsePth.dir, newfn);
                if (outpath.slice(-5).toLowerCase() != '.json') { outpath += '.json'; }

                let resp = transform(tsvObj, jsonObj, outpath);
                fs.writeFileSync(outpath, JSON.stringify(resp, null, 4), { encoding:'utf8' });

                break;

            default:
                log(cp.yellow.bold.paint(`${cp.red.paint('ERROR: ')}Unknown command`));
                break;
        }
        log(`\n${cp.green.paint('FINISHED:')} in ${Math.round(new Date().getTime() - startTime, 2)} miliseconds`);
    }

    function makePath(pth, fn) { 
        pth = path.normalize(pth);
        if (path.isAbsolute(pth)) { 
            return fn ? path.join(pth, fn) : pth;
        } else {
            return fn ? path.join(__dirname, pth, fn) : path.join(__dirname, pth);
        }
    }

    function endThis(msg, code = 0) {
        log(msg);
        process.exit(code);
    }

    // --------------------------------------------
    // TRANSLATE: Traduz usando o Google Translator
    // --------------------------------------------
    async function translate(json, lang, outlang) { 
        let arr = props2Array(json, lang, outlang); 
        let newJson = JSON.parse(JSON.stringify(json));
        arr.shift();
        let tasks = [];

        arr.forEach(line => {
            tasks.push(new Promise(async function(resolve, reject) {
                try {
                    let tmparr = line.split('\t'), translated;
                    let re = /[\w\-_$]\.[\w\-_$]|[\w\-_$][(\/|\\)][\w\-_$]/;

                    // Só traduz se não for número e nem arquivo ou url (no caso se tiver chars seguidos de ponto, seguido de chars. Tipo: file.png)
                    if (isNaN(tmparr[1]) && !tmparr[1].match(re)) {
                        translated = await translateGoogle(tmparr[1], lang, outlang);
                    } else {
                        translated = tmparr[1];
                    }
                    dotNotation(newJson, tmparr[0], translated);
                    resolve(true);
    
                } catch (error) {
                    reject(error);
                }
            }));
        });

        try {
            let resp = await Promise.all(tasks);
            return newJson;    

        } catch (error) {
            endThis(`${cp.red.paint('ERROR: ')}[${error.message.replace(':', ']')}`, 1);
        }

    }

    
    
    // --------------------------------------------------
    // PREPARE: Prepara o conteúdo de um novo arquivo TSV
    // --------------------------------------------------
    function prepare(json, lang, outlang) {
        let arr = props2Array(json, lang, outlang);
        let resp = arr.join(os.EOL);
        return resp;
    }


    // ---------------------------------------------------
    // TRANSFORM: Texto TSV traduzido entra, novo JSON sai
    // ---------------------------------------------------
    function transform(tsv, json, outputPath) {
        let len = tsv.length;

        for (var i = 1; i < len; i++) {
            let lineArr = tsv[i].split('\t');
            
            if (lineArr.length >= 3) {
                let dots = lineArr[0], value = lineArr[2];
                dotNotation(json, dots, value);
            }
        }
        return json;
    }    

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // -----------------------------------------------------------------
    // Retorna ou seta (e tb retorna) um valor num objeto ou array (obj)
    // interpretando o dotnotation em is
    // -----------------------------------------------------------------
    function dotNotation(obj, dotArr, value) {
        if (typeof dotArr == 'string') {
            // Tenta de novo com is como array
            return dotNotation(obj, dotArr.split('.'), value);

        } else if (dotArr.length == 1 && value !== undefined) {
            // Chegamos no ramo da árvore.
            if (isNaN(dotArr[0])) {
                // Se o argumento não for numérico, é um objeto, basta setar o valor
                return obj[dotArr[0]] = value;
            } else {
                // Se já for um array, acrescenta o item, senão cria o array com o item
                if (Array.isArray(obj)) { obj[+dotArr[0]] = value; } else { obj = [value]; }
            }
        } else if (dotArr.length==0) {
            // Se is for vazio, retorna o objeto
            return obj;
        } else {
            // Gira a roda
            return dotNotation(obj[dotArr[0]], dotArr.slice(1), value);
        }

        let xx = { 0: '12', 1: '3' }
    }


    // -----------------------------------------------------------------------------------
    // Retorna um array com o dotnotation de cada propriedade do objeto passado em obj Ex:
    // obj = { a: { b: { c: 'olá' } }}
    // Vai retornar:
    // a.b.c [TAB] olá [TAB]
    // Com a seguinte linha título: 'Identificador' [TAB] originalLang [TAB] targetLang
    // -----------------------------------------------------------------------------------
    function props2Array(obj, originalLang, targetLang) {
        const isObject = val => val && typeof val === 'object'// && !Array.isArray(val);
        const addDelimiter = (a, b) => a ? `${a}.${b}` : b;

        const paths = (obj = {}, head = '') => {
            return Object.entries(obj).reduce((product, [key, value]) => {
                let fullPath = addDelimiter(head, key)
                return isObject(value) ? product.concat(paths(value, fullPath)) : product.concat(fullPath + '\t' + value + '\t');
            }, []);
        }

        let resp = paths(obj);
        resp.unshift('Identificador\t' + originalLang + '\t' + targetLang);
        return resp;
    }


    // ---------------------------------------------------------
    // Faz a tradução do texto em txt usando o serviço do Google
    // tolang e fromlang são as línguas e interval é o tempo 
    // entre chamadas em milisegundos
    // ---------------------------------------------------------
    async function translateGoogle(txt, fromlang, tolang, interval = 300) {
        return new Promise((resolve) => {
            if (!txt.trim()) { 
                resolve(''); 
            } else {
                setTimeout(() => {
                    googleTrans(txt, { from: fromlang, to: tolang }).then(function(res) {
                        resolve(res.text);

                    }).catch((error) => { 
                        log(error); 
                        resolve(''); 
                    });
                }, interval);
            }     
        });
    }
}());